# D5. Design

Group 01 – “Golf-N-Stuff”\
Group Members: Alden Smith, Kendall Callison, Tomas Jauregui, Andrew Milizia, 
Kristiana Kirk, Corey Moreno

## 1. Description
Golf-N-Stuff is a browser-based mini golf simulator that allows office workers and gamers to slack off more efficiently without the need to worry. Having a free minigolf game right in your browser makes it all the more convenient to hide your office shenanigans from prying eyes. With our intuitive and realistic golf controls it makes you feel like you are actually hitting the ball! Golf-N-Stuff offers a realistic and sophisticated golf ball physics system that will leave you in awe as you thwack the ball across the range. The creative level design we hand crafted will keep you captivated through the twists and turns of each course while you procrastinate other important tasks. Lastly with our advanced menu design and quality of life features you can easily pick up a new game or start a specific level. It’s so easy, even a toddler can play.\
\
Project repo: [Golf-N-Stuff](https://github.com/Major-Lag98/Golf-N-Stuff) \
Activity tracker: [Activity Tracker](https://docs.google.com/spreadsheets/d/1M-PDM2CbciqlwUuVesri6JO3uoLaDBUZoQeGvvvWWRk/edit?usp=sharing)

## 2. Architecture 

## 3. Class Diagram

## 4. Sequence Diagram

## 5. Design Patterns

## 6. Design Principles

Single responsibility principle - 
Button behavior class only does have one responsibility, the ability to change the slider and nothing else. It does not handle anything else besides that.

open-closed principle- 
The watch class can be reset and continued with any other class inside the game, but the source code remains the same due to it being a static class. This static class only starts with the stopwatch and starts the score. So it can be changed without the source code being modified.

Liskov substitution principle -
this does not apply to our code since we use more procedural code and composition rather than inheritance 

segregation principle - 
Since our code relies on composition rather than inheritance, our objects are allowed to pick the functions that they want from instances of the other classes rather than relying on taking all of the classes functions from the parent. So this principle is held.

dependency inversion principle-
Inheritance is not used in our code, so abstractions between components are not used so the principle is withheld.

Note:
Most of our code uses a procedural style of implementation with use of compositions for implementation other functions from other objects. We do not use OOP to the full extend so most of these principles are unable to be applied in this case. We have not implementation of inheritance since all of our objects rely on each other with instances and our objects are unable to be abstracted from since they are too different.


